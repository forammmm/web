<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Zen Drawing Pad</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body { height:100%; margin:0; }
    body {
      background: linear-gradient(135deg,#f0f7ff 0%, #fff4f8 50%, #fbfefc 100%);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Layout helpers */
    .app {
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      box-sizing: border-box;
    }

    .canvas-wrap {
      width: 100%;
      max-width: 900px;
      flex: 1 1 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 12px;
      margin-bottom: 12px;
    }

    .paper {
      width: 100%;
      height: 100%;
      max-height: calc(100vh - 180px);
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(2,6,23,0.08);
      background: white;
      overflow: hidden;
      touch-action: none; /* prevents scrolling while drawing */
      position: relative;
      display: flex;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: crosshair;
    }

    /* Small UI tweaks */
    .tool {
      background: rgba(255,255,255,0.7);
      backdrop-filter: blur(6px);
      border-radius: 999px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.06);
    }
  </style>
</head>
<body>
  <div class="app">

    
    <header class="w-full max-w-3xl flex items-center justify-between gap-3">
      <div class="flex items-center gap-3">
        <button onclick="history.back()" class="tool px-3 py-2 rounded-full text-sm">⬅ Back</button>
        <div>
          <h1 class="text-lg font-semibold text-slate-800 leading-none">Zen Drawing Pad</h1>
          <p class="text-xs text-slate-600">Draw freely — relax and flow</p>
        </div>
      </div>

      <div class="flex items-center gap-2">
    
        <label class="tool px-3 py-2 flex items-center gap-2">
          <input id="color" type="color" class="w-8 h-8 p-0 border-0" value="#5b21b6" title="Brush color">
          <span class="text-sm text-slate-700">Color</span>
        </label>

       
        <label class="tool px-3 py-2 flex items-center gap-2">
          <input id="size" type="range" min="1" max="60" value="18" class="w-24" />
          <span id="sizeLabel" class="text-sm text-slate-700">18</span>
        </label>

       
        <button id="clearBtn" class="tool px-3 py-2 rounded-full text-sm">Clear</button>

       
        <button id="saveBtn" class="tool px-3 py-2 rounded-full text-sm">Save</button>
      </div>
    </header>

   
    <div class="canvas-wrap w-full max-w-3xl">
      <div class="paper w-full">
        <canvas id="pad"></canvas>
      </div>
    </div>

   
    <footer class="w-full max-w-3xl text-center text-sm text-slate-600">
      Tip: Use two fingers to pinch/zoom the page (drawing is single-touch). Works best with one finger or mouse.
    </footer>
  </div>

  <script>
    // ===== Zen Drawing Pad =====
    const canvas = document.getElementById('pad');
    const colorEl = document.getElementById('color');
    const sizeEl = document.getElementById('size');
    const sizeLabel = document.getElementById('sizeLabel');
    const clearBtn = document.getElementById('clearBtn');
    const saveBtn = document.getElementById('saveBtn');

    let ctx, DPR, width, height;
    let drawing = false;
    let lastPoint = null;
    let points = []; // for smoothing
    let brushColor = colorEl.value;
    let brushSize = parseInt(sizeEl.value, 10);

    // initialize canvas size (respect devicePixelRatio)
    function resizeCanvas() {
      DPR = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      // if zero (not yet attached), use parent size
      const parent = canvas.parentElement;
      const pw = parent.clientWidth;
      const ph = parent.clientHeight;
      width = Math.max(300, pw);
      height = Math.max(300, ph);
      canvas.width = Math.floor(width * DPR);
      canvas.height = Math.floor(height * DPR);
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      ctx = canvas.getContext('2d', { alpha: true });
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      // canvas initial config
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      redraw(); // keep current drawing (if any)
    }

    // drawing state management
    function startStroke(x, y) {
      drawing = true;
      points = [{x, y, t: Date.now()}];
      lastPoint = {x, y};
      drawDot(x, y); // initial dot to avoid gap
    }

    function moveStroke(x, y) {
      if (!drawing) return;
      points.push({x, y, t: Date.now()});
      if (points.length >= 3) {
        // draw using quadratic Bezier through previous points for smoothing
        const prev = points[points.length - 3];
        const ctrl = points[points.length - 2];
        const curr = points[points.length - 1];
        const cpx = ctrl.x;
        const cpy = ctrl.y;
        const toX = (ctrl.x + curr.x) / 2;
        const toY = (ctrl.y + curr.y) / 2;

        const pressure = calcPressure(prev, ctrl, curr); // estimated pressure based on speed
        const size = brushSize * pressure;

        ctx.strokeStyle = brushColor;
        ctx.lineWidth = size;
        ctx.beginPath();
        ctx.moveTo(prev.x, prev.y);
        ctx.quadraticCurveTo(cpx, cpy, toX, toY);

        // subtle glow (soft brush)
        ctx.shadowBlur = Math.max(brushSize * 0.6, 6);
        ctx.shadowColor = brushColor;
        ctx.globalCompositeOperation = 'source-over';
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else {
        drawDot(x, y);
      }
      lastPoint = {x, y};
    }

    function endStroke() {
      drawing = false;
      points = [];
      lastPoint = null;
    }

    // draws a filled dot (used for taps)
    function drawDot(x, y) {
      ctx.fillStyle = brushColor;
      ctx.beginPath();
      ctx.shadowBlur = Math.max(brushSize * 0.6, 6);
      ctx.shadowColor = brushColor;
      ctx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // estimated pressure based on movement speed (slower = thicker)
    function calcPressure(a, b, c) {
      const dx = c.x - a.x;
      const dy = c.y - a.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      // normalize into 0.5..1.2 range
      const p = Math.max(0.5, Math.min(1.2, 1.2 - (dist / 120)));
      return p;
    }

    // clear canvas
    function clearCanvas() {
      ctx.clearRect(0, 0, width, height);
    }

    // save as PNG
    function saveImage() {
      // create a white background composite so saved image has white paper
      const tmp = document.createElement('canvas');
      tmp.width = canvas.width;
      tmp.height = canvas.height;
      const tctx = tmp.getContext('2d');
      tctx.fillStyle = '#ffffff';
      tctx.fillRect(0,0,tmp.width,tmp.height);
      // draw current canvas on top (scale for DPR)
      tctx.drawImage(canvas, 0, 0, tmp.width, tmp.height);
      const url = tmp.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = `zen-drawing-${Date.now()}.png`;
      a.click();
    }

    // redraw - placeholder if we implement persistent layers later
    function redraw() {
      // for now nothing persistent to reapply (we draw directly)
    }

    // Pointer event helpers (normalize mouse & touch)
    function getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches && e.touches.length) {
        return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
      } else if (e.changedTouches && e.changedTouches.length) {
        return { x: e.changedTouches[0].clientX - rect.left, y: e.changedTouches[0].clientY - rect.top };
      } else {
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }
    }

    // Event wiring
    function attachEvents() {
      // Mouse
      canvas.addEventListener('mousedown', (e) => {
        const p = getPointerPos(e);
        startStroke(p.x, p.y);
      });
      window.addEventListener('mousemove', (e) => {
        if (!drawing) return;
        const p = getPointerPos(e);
        moveStroke(p.x, p.y);
      });
      window.addEventListener('mouseup', () => endStroke());

      // Touch
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const p = getPointerPos(e);
        startStroke(p.x, p.y);
      }, { passive: false });
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const p = getPointerPos(e);
        moveStroke(p.x, p.y);
      }, { passive: false });
      canvas.addEventListener('touchend', (e) => {
        endStroke();
      });

      // UI controls
      colorEl.addEventListener('input', (e) => { brushColor = e.target.value; });
      sizeEl.addEventListener('input', (e) => {
        brushSize = parseInt(e.target.value,10);
        sizeLabel.textContent = brushSize;
      });
      clearBtn.addEventListener('click', () => {
        // gentle fade-out clear animation
        const fadeSteps = 6;
        let step = 0;
        const id = setInterval(() => {
          ctx.fillStyle = `rgba(255,255,255,${(step+1)/(fadeSteps+1)})`;
          ctx.fillRect(0,0,width,height);
          step++;
          if (step >= fadeSteps) {
            clearInterval(id);
            clearCanvas();
          }
        }, 35);
      });
      saveBtn.addEventListener('click', saveImage);

      window.addEventListener('resize', () => resizeCanvas());
    }

    // init
    setTimeout(() => {
      // ensure parent sizes settled
      resizeCanvas();
      attachEvents();
    }, 80);

    // prevent double-tap to zoom on mobile interfering with drawing
    document.addEventListener('touchstart', function(e) {
      if (e.touches.length > 1) e.preventDefault();
    }, {passive:false});
  </script>
</body>
</html>


